from django.shortcuts import render
from django.core.paginator import Paginator
from .models import RoverPhoto, NASAPhoto
import requests


# Create your views here.
# Generated by Django 4.2.2 on 2023-07-03 13:20
from django.views.generic import ListView
from django.shortcuts import render, get_object_or_404
from .models import SolarSystemPlanets, SSPMeasurement, PlanetarySystems
from django.core.paginator import Paginator
from django.db.models import Q
from math import pi, log
from dal import autocomplete
from .forms import PlanetForm, PlanetarySystemForm
import logging
import math


logger = logging.getLogger(__name__)

#------------------------------------------------------------------------------------------------------------------------------
# function to check if any values in an iterable are None
def any_none(values):
    return any(value is None for value in values)


#------------------------------------------------------------------------------------------------------------------------------
# views to handle various pages and actions on the website
def homepage(request):
    return render(request, 'universe_db/homepage.html')


#------------------------------------------------------------------------------------------------------------------------------
# fetches all planet objects and passes them to the 'planet_list' template
def planet_list(request):
    planets = SolarSystemPlanets.objects.all()
    return render(request, 'universe_db/planet_list.html', {'planets': planets})


#------------------------------------------------------------------------------------------------------------------------------
# fetches a single planet and its related measurements, and passes them to the 'planet_detail' template
def planet_detail(request, planet_name):
    planet = get_object_or_404(SolarSystemPlanets, name=planet_name)        #raises 404 error if the planet name object is not found
    measurements = SSPMeasurement.objects.filter(planet=planet)
    #print(planet)  # Check if planet data is correct
    #print(measurements)  # Check if measurements data is correct
    return render(request, 'universe_db/planet_detail.html', {'planet': planet, 'measurements': measurements})


#------------------------------------------------------------------------------------------------------------------------------
def exoplanets(request):
    planetary_systems = PlanetarySystems.objects.all()
    return render(request, 'universe_db/exoplanets.html', {'planetary_systems': planetary_systems})


#------------------------------------------------------------------------------------------------------------------------------
#fetches all planetary systems, filters them based on query parameters, paginates the results, and passes them to the 'planetary_systems' template
def planetary_systems(request):
    filtered_systems = PlanetarySystems.objects.all()

    # Get the search queries from the request parameters
    search_fields = [
        'name',
        'hostname',
        'number_of_stars',
        'number_of_planets',
        'discovery_method',
        'discovery_year',
        'discovery_facility',
        'orbit_period',
        'radius',
        'mass',
        'equilibrium_temperature',
        'spectral_type',
        'stellar_effective_temp',
        'stellar_mass',
        'stellar_metallicity',
        'stellar_metallicity_ratio',
        'stellar_surface_gravity',
        'ra',
        'dec',
        'distance',
        'eccentricity',
        'stellar_radius',
        'semimajor_axis',
        'impact_parameter',

    ]

    # Create a Q object to combine the query conditions
    q_object = Q()

    for field in search_fields:
        # Get the query parameter value
        query_value = request.GET.get(field, None)

        if query_value is not None and query_value != '':
            # Create a new Q object for this field and add it to the main Q object
            filtered_systems = filtered_systems.filter(**{f'{field}__contains': query_value})
            print(str(filtered_systems.query))



    filtered_systems = filtered_systems.order_by('id')
    paginator = Paginator(filtered_systems, 50)  # Number of items per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'request': request.GET,  # Pass the request.GET to access the search query in the template
        #'planetary_system_form': PlanetarySystemForm(),

    }

    return render(request, 'universe_db/planetary_systems.html', context)


#------------------------------------------------------------------------------------------------------------------------------
# handles various calculations for planets and planetary systems based on form data and calculation type
def calculate(request):
    # Create instances of both forms
    planet_form = PlanetForm(request.GET or None)
    planetary_system_form = PlanetarySystemForm(request.GET or None)

    logger.info('planet_form data: %s', planet_form.data)
    logger.info('planetary_system_form data: %s', planetary_system_form.data)

    # Initialize the result
    result = None

    # Get the selected calculation
    calculation = request.GET.get('calculation', None)
    logger.info('calculation: %s', calculation)

    # If a planet is selected
    if planet_form.is_valid():
        planet = planet_form.cleaned_data.get('name')
    else:
        planet = None
    logger.info('planet: %s', planet)

    # If a planetary system is selected
    if planetary_system_form.is_valid():
        planetary_system = planetary_system_form.cleaned_data.get('name')
    else:
        planetary_system = None
    logger.info('planetary_system: %s', planetary_system)



    #Constants:

    sigma = 5.67e-8     # Stefan-Boltzmann constant ( W/m^2.K^4 )
    grav_const = 6.67430 * (10**-11)    #Gravitational Constant (10⁻¹¹ m³ kg⁻¹ s⁻²)




    #EXOPLANET SURFACE GRAVITY
    if calculation == 'exo_surface_gravity':
        if any_none([planetary_system.mass, planetary_system.radius]):
            result = "Cannot calculate, insufficient data"
        else:
            exoplanet_mass = planetary_system.mass * 1.898e27
            exoplanet_radius = planetary_system.radius * 6.9911e7

            result = (grav_const * exoplanet_mass) / (exoplanet_radius**2)

    #STELLAR LUMINOSITY
    elif calculation == 'luminosity':
        if any_none([planetary_system.stellar_radius, planetary_system.stellar_effective_temp]):
            result = "Cannot calculate, insufficient data"
        else:
            star_radius = planetary_system.stellar_radius * 6.9634e8
            star_temperature = planetary_system.stellar_effective_temp

            # Estimate the luminosity of the star
            result = 4 * pi * (star_radius ** 2) * sigma * (star_temperature ** 4)

    #ESCAPE VELOCITY
    elif calculation == 'escape_velocity':
        if any_none([planetary_system.mass, planetary_system.radius]):
            result = "Cannot calculate, insufficient data"
        else:
            exoplanet_mass = planetary_system.mass * 1.898e27
            exoplanet_radius = planetary_system.radius * 6.9911e7

            result = (((2 * grav_const * exoplanet_mass) / exoplanet_radius)**.5) / 1000

    #EXOPLANET DENSITY
    elif calculation == 'exo_density':
        if any_none([planetary_system.mass, planetary_system.radius]):
            result = "Cannot calculate, insufficient data"
        else:
            exoplanet_mass = planetary_system.mass * 1.898e27
            exoplanet_radius = planetary_system.radius * 6.9911e7

            result = exoplanet_mass / ((4/3) * pi * exoplanet_radius**3)

    #TRANSIT DURATION
    elif calculation == 'transit_dur':
        exorad = planetary_system.radius * 0.10049
        semaxis = planetary_system.semimajor_axis * 215.032

        if any_none([planetary_system.orbit_period, planetary_system.stellar_radius, planetary_system.semimajor_axis, planetary_system.radius, planetary_system.impact_parameter, planetary_system.eccentricity]):
            result = "Cannot calculate, insufficient data"
        else:
            p1 = (planetary_system.orbit_period / pi)
            p2 = (planetary_system.stellar_radius / semaxis)
            p3 = ((1 + (exorad / planetary_system.stellar_radius))**2 - planetary_system.impact_parameter**2)**.5


            inner_asin = p2 * p3 / (1 - planetary_system.eccentricity**2)**.5
            print(inner_asin)

            if not -1 <= inner_asin <= 1:       #parameters of arcsin must be between -1 and 1 
                result = "Invalid input for arcsin function"
            else:
                result = p1 * math.asin(inner_asin)











    logger.info('result: %s', result)

    if result is not None:  # Makes sure that result is not None before comparing
        if isinstance(result, float) and result > 10000:  # Check if the result is a float
            result = "{:.3e}".format(result)
        elif isinstance(result, float):  # Check if the result is a float
            result = "{:.3f}".format(result)


    return render(request, 'universe_db/calculations.html', {'result': result, 'planet_form': planet_form, 'planetary_system_form': planetary_system_form, 'calculation': calculation})

#------------------------------------------------------------------------------------------------------------------------------
# Defines a custom autocomplete view for planet and planetary system selection in forms
class PlanetAutocomplete(autocomplete.Select2QuerySetView):

    #define what data should be returned based on the search term.
    def get_queryset(self):

        # If the user making the request is not authenticated, no planets are returned.
        if not self.request.user.is_authenticated:
            return SolarSystemPlanets.objects.none()

        # Start with a queryset that includes all planets.
        qs = SolarSystemPlanets.objects.all()

        # If a search term (self.q) is provided, we filter the queryset to include only planets whose names start with the search term (ignoring case differences).
        if self.q:
            qs = qs.filter(name__istartswith=self.q)

        return qs


class PlanetarySystemAutocomplete(autocomplete.Select2QuerySetView):

    def get_queryset(self):
        qs = PlanetarySystems.objects.all()
        search_term = self.q


        if search_term:
            qs = qs.filter(name__icontains=search_term)

        return qs

#------------------------------------------------------------------------------------------------------------------------------
#MARS PHOTOS

def mars_photos(request):
    photos_list = RoverPhoto.objects.all()  # Fetch all RoverPhoto objects from the database
    paginator = Paginator(photos_list, 25)  # Show 25 photos per page

    page = request.GET.get('page')
    photos = paginator.get_page(page)

    return render(request, 'universe_db/mars_photos.html', {'photos': photos})


#------------------------------------------------------------------------------------------------------------------------------
#NASA PHOTO OF THE DAY

def nasa_photos(request):
    photos_list = NASAPhoto.objects.all()  # Fetch all RoverPhoto objects from the database
    paginator = Paginator(photos_list, 25)  # Show 25 photos per page

    page = request.GET.get('page')
    photos = paginator.get_page(page)

    return render(request, 'universe_db/nasa_photos.html', {'photos': photos})
